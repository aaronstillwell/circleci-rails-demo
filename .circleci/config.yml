version: 2.1

orbs:
  heroku: circleci/heroku@0.0.8
  orbs-audit:
    orbs:
      circleci-cli: circleci/circleci-cli@0.1.8
    jobs:
      # Check for outdated orbs in this config
      audit:
        parameters:
          config_file_location:
            type: string
            default: .circleci/config.yml
          fail_on_unpinned:
            type: boolean
            default: true
        executor: circleci-cli/default
        resource_class: small
        steps:
          - run:
              name: Install yq 3.3.0
              command: |
                curl --output yq --silent --show-error --location --fail --retry 3 \
                https://github.com/mikefarah/yq/releases/download/3.3.0/yq_linux_amd64
                sudo mv yq /usr/local/bin/
                chmod +x /usr/local/bin/yq
          - checkout
          - run:
              name: Scanning .circleci/config.yml for outdated orbs
              command: |
                # Globals passed from parameters
                CONFIG_FILE_LOCATION=<< parameters.config_file_location >>
                FAIL_ON_UNPINNED=<< parameters.fail_on_unpinned >>

                # Color related vars
                RED='\033[0;31m'
                GREEN='\033[0;32m'
                YELLOW='\033[0;33m'
                NC='\033[0m'

                # Exit code to be returned at the end
                STATUS=0

                # Helper functions for printing colored text to stdout

                print_green() {
                  echo -e "${GREEN}${1}${NC}"
                }

                print_yellow() {
                  echo -e "${YELLOW}${1}${NC}"
                }

                print_red() {
                  echo -e "${RED}${1}${NC}"
                }

                # Print a problem in either red or yellow, depending on how the command is
                # configured
                print_problem() {
                  print_red "${1}"
                }

                # $1 -> fully qualified orb ref
                # $2 -> type
                # $3 -> message
                # $4 -> assertions
                generate_failed_xml() {
                  echo "<testcase name=\"${1}\" file=\"${CONFIG_FILE_LOCATION}\" assertions='${4}'><failure type=\"${2}\" message=\"${2}\"></failure></testcase>"
                }

                #
                generate_error_xml() {
                  echo "<testcase name=\"${1}\" file=\"${CONFIG_FILE_LOCATION}\" assertions='${4}'><error type=\"${2}\">${3}</error></testcase>"
                }

                # $1 -> fully qualified orb ref
                generate_passed_xml() {
                  echo "<testcase name=\"${1}\" file=\"${CONFIG_FILE_LOCATION}\" assertions='${2}'></testcase>"
                }

                # TODO fail if file is not present

                XML=""
                ERROR_COUNT=0
                FAIL_COUNT=0
                SKIPPED_COUNT=0
                TESTS_COUNT=0
                ASSERTION_COUNT=0

                ORBS=$(cat ${CONFIG_FILE_LOCATION} | yq r - "orbs.*")
                while IFS= read -r orb; do
                  ORB_REGEX="^([A-z_-]+)\/([A-z_-]+)(@([0-9]+)(\.([0-9]+))?(\.([0-9]+))?)?$"

                  if ! [[ $orb =~ $ORB_REGEX ]]; then
                    # Skip inline orbs, orbs using parameters
                    continue
                  fi

                  TESTS_COUNT=$((TESTS_COUNT+1))
                  ASSERTION_COUNT=$((ASSERTION_COUNT+1))

                  META=$(circleci --skip-update-check orb info $orb)
                  REGEX="Latest: [A-z-]+\/[A-z-]+@([0-9]+)\.([0-9]+)\.([0-9]+)"

                  if [[ $META =~ $REGEX ]]; then
                    LATEST_MAJOR=${BASH_REMATCH[1]}
                    LATEST_MINOR=${BASH_REMATCH[2]}
                    LATEST_PATCH=${BASH_REMATCH[3]}

                    ASSERTION_COUNT=$((ASSERTION_COUNT+1))
                    # Don't think ERE supports non-capture groups
                    CURRENT_REGEX="@([0-9]+)(\.([0-9]+))?(\.([0-9]+))?"
                    if [[ $orb =~ $CURRENT_REGEX ]]; then

                      CURRENT_MAJOR=${BASH_REMATCH[1]}
                      CURRENT_MINOR=${BASH_REMATCH[3]}
                      CURRENT_PATCH=${BASH_REMATCH[5]}

                      # TODO: support less specific orb pinning

                      ASSERTION_COUNT=$((ASSERTION_COUNT+1))
                      if [ "$CURRENT_MAJOR" != "" ]; then
                        if [ $CURRENT_MAJOR -ne $LATEST_MAJOR ]; then
                          # New major version available
                          print_problem "New major version of ${orb} available"
                          XML+=$(generate_failed_xml ${orb} "New major version available" "A new major version of this orb is available" 3)
                          FAIL_COUNT=$((FAIL_COUNT+1))
                          STATUS=1
                          continue
                        fi
                      fi

                      ASSERTION_COUNT=$((ASSERTION_COUNT+1))
                      if [ "$CURRENT_MINOR" != "" ]; then
                        if [ $CURRENT_MINOR -ne $LATEST_MINOR ]; then
                          # New major minor available
                          print_problem "New minor version of $orb available"
                          XML+=$(generate_failed_xml ${orb} "New minor version available" "A new minor version of this orb is available" 4)
                          FAIL_COUNT=$((FAIL_COUNT+1))
                          STATUS=1
                          continue
                        fi
                      fi

                      ASSERTION_COUNT=$((ASSERTION_COUNT+1))
                      if [ "$CURRENT_PATCH" != "" ]; then
                        if [ $CURRENT_PATCH -ne $LATEST_PATCH ]; then
                          # New patch version available
                          print_problem "New patch version of $orb available"
                          XML+=$(generate_failed_xml ${orb} "New minor version available" "A new patch sversion of this orb is available" 5)
                          FAIL_COUNT=$((FAIL_COUNT+1))
                          STATUS=1
                          continue
                        fi
                      fi

                      print_green "${orb} is up to date"
                      XML+="$(generate_passed_xml ${orb} 5)"
                    else
                      print_red "Couldn't identify pinned version of $orb"
                      XML+=$(generate_error_xml ${orb} "Could not identify pinned version" "Could not identify the pinned version of ${orb}" 2)
                      FAIL_COUNT=$((FAIL_COUNT+1))
                      if $FAIL_ON_UNPINNED ; then
                        STATUS=1
                      fi
                    fi
                  else
                    print_red "Could not find orb info for $orb"
                    ERROR_COUNT=$((ERROR_COUNT+1))
                    XML+=$(generate_error_xml ${orb} "Orb not found" "Could not find orb ${orb} in the registry" 1)
                    STATUS=1
                  fi
                done \<<< "${ORBS}"

                TIMESTAMP=`date +%Y-%m-%dT%H:%M:%S%:z`
                XML=$(printf "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuite skipped='${SKIPPED_COUNT}' assertions='${ASSERTION_COUNT}' errors='${ERROR_COUNT}' failures='${FAIL_COUNT}' tests='${TESTS_COUNT}' name=\"Outdated orbs helper\" timestamp=\"${TIMESTAMP}\">\n${XML}\n")
                XML+="</testsuite>"

                mkdir -p ".outdated-orbs-helper"

                echo "${XML}" > ".outdated-orbs-helper/results.xml"

                exit $STATUS
          - store_test_results:
              path: .outdated-orbs-helper/
          - store_artifacts:
              path: .outdated-orbs-helper/

app_env: &app_env
  environment:
    NODE_VERSION: 1.10.6
    YARN_VERSION: 1.17.0
    BUNDLER_VERSION: 2.0.2
    BUNDLE_PATH: vendor/bundle
    GEM_HOME: .gem
    GEM_PATH: .gem
    RAILS_ENV: test
    DATABASE_HOST: 127.0.0.1
    TESTOPTS: "--ci-dir=test/reports"

executors:
  ruby-node:
    docker:
      - image: cimg/ruby:2.6.6-node
        <<: *app_env
  ruby-node-postgres:
    docker:
      - image: cimg/ruby:2.6.6-node
        <<: *app_env
      - image: circleci/postgres:11-alpine
        environment:
          POSTGRES_DB: rails_db
          POSTGRES_USER: rails_db_user
          POSTGRES_PASSWORD: rails_db_pw

jobs:

  # Scan for vulnerabilities in ruby dependencies using bundler_audit
  ruby_dependency_scan:
    docker:
      - image: circleci/ruby:2.6.6
    resource_class: small
    steps:
      - checkout
      - run:
          name: Install bundler-audit 0.7
          command: sudo gem install bundler-audit -v 0.7
      - run:
          name: Run bundle-audit
          command: sudo bundle-audit check --update

  #
  # Build jobs
  #

  # Install ruby dependencies
  build_ruby:
    executor: ruby-node
    steps:
      - checkout

      - run:
          name: Install bundler
          command: gem install bundler -v $BUNDLER_VERSION

      - restore_cache:
          keys:
            - Gemfile-{{ .Branch }}-{{ checksum "Gemfile.lock" }}
            - Gemfile-{{ .Branch }}
            - Gemfile-

      - run:
          name: Install ruby dependencies
          command: bundle install
      
      - run:
          name: Check rails works
          command: bundle exec rails --version

      - save_cache:
          key: Gemfile-{{ .Branch }}-{{ checksum "Gemfile.lock" }}
          paths:
            - vendor/bundle
      
      - persist_to_workspace:
          root: .
          paths:
            - vendor/bundle
            - .gem
  
  # Install JS dependencies
  build_js:
    executor: ruby-node
    steps:
      - checkout

      - restore_cache:
          keys:
            - npm-{{ .Branch }}-{{ checksum "yarn.lock" }}
            - npm-{{ .Branch }}
            - npm-

      - run:
          name: Install JS dependencies
          command: yarn install

      - save_cache:
          key: npm-{{ .Branch }}-{{ checksum "yarn.lock" }}
          paths:
            - node_modules
      
      - persist_to_workspace:
          root: .
          paths:
            - node_modules
  
  #
  # Test jobs
  #
  
  test_rails:
    executor: ruby-node-postgres
    steps:
      - checkout

      - attach_workspace:
          at: .
      
      - run:
          name: Wait for db
          command: |
            dockerize -wait tcp://localhost:5432 -timeout 1m

      - run:
          name: Setup database
          command: bundle exec rails db:create db:schema:load

      - run:
          name: Run rails tests
          command: bundle exec rails test

      - store_test_results:
          path: test/reports

      - store_artifacts:
          path: test/reports
  
  test_js:
    executor: ruby-node
    steps:
      - checkout

      - attach_workspace:
          at: .

      - run:
          name: Run JS tests
          # TODO
          command: yarn --version
  
  #
  # Deploy Jobs
  #

  deploy_database_migrations:
    executor: ruby-node
    resource_class: small
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run: bundle exec rails db:migrate RAILS_ENV=production
  
  deploy_terraform:
    docker:
      - image: hashicorp/terraform:0.12.29
        environment:
          TF_IN_AUTOMATION: true
    resource_class: small
    steps:
      - checkout
      - run:
          name: Terraform init
          command: | 
            cd terraform
            terraform init -input=false
      - run:
          name: Terraform plan
          command: |
            cd terraform
            terraform plan -input=false
      - run:
          name: Terraform apply
          command: |
            cd terraform
            terraform apply -input=false -auto-approve

workflows:
  build_and_test:
    jobs:
      - ruby_dependency_scan
      - orbs-audit/audit
      - build_ruby
      - build_js
      - test_js:
          requires: 
           - build_js
      - test_rails:
          requires:
           - build_ruby
           - build_js
      - hold_for_deploy:
          type: approval
          requires:
            - ruby_dependency_scan
            - test_rails
            - test_js
          filters:
            branches:
              only: master
      - deploy_database_migrations:
          requires:
           - hold_for_deploy
          context: circleci-rails-prod
      - deploy_terraform:
          requires:
            - hold_for_deploy
          context: circleci-rails-prod
      - heroku/deploy-via-git:
          requires:
            - deploy_database_migrations
            - deploy_terraform
          context: circleci-rails-prod
  nightly_security_scan:
    jobs:
      - ruby_dependency_scan
      - orbs-audit/audit
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches: 
              only: master